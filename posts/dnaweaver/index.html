<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>DNA construction strategies from graph algorithms | Bricks and Scissors</title>
<meta name=keywords content="synbio,DNA,assembly,software">
<meta name=description content="Note: This is a bloggification of these IWBDA 2019 slides on how path-finding tricks used in Google Maps and strategy games can also help build long DNA molecules.
   Story time! The Edinburgh Genome Foundry, where I worked a few years, is a platform that sells custom synthetic DNA. Customers email long sequences (ATGCTAC..., typically 10,000 bases or longer) which an automated setup will produce, generally by assembling smaller DNA fragments into bigger ones.">
<meta name=author content="Zulko">
<link rel=canonical href=https://zulko.github.io/bricks_and_scissors/posts/dnaweaver/>
<link href=/bricks_and_scissors/assets/css/stylesheet.min.b402348252ee2a7460aa3802eac182e55caeb117c9317b7aeda6c8501312fbd6.css integrity="sha256-tAI0glLuKnRgqjgC6sGC5VyusRfJMXt67abIUBMS+9Y=" rel="preload stylesheet" as=style>
<link rel=icon href=https://zulko.github.io/bricks_and_scissors/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://zulko.github.io/bricks_and_scissors/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://zulko.github.io/bricks_and_scissors/favicon-32x32.png>
<link rel=apple-touch-icon href=https://zulko.github.io/bricks_and_scissors/apple-touch-icon.png>
<link rel=mask-icon href=https://zulko.github.io/bricks_and_scissors/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.87.0">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-194244778-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="DNA construction strategies from graph algorithms">
<meta property="og:description" content="Note: This is a bloggification of these IWBDA 2019 slides on how path-finding tricks used in Google Maps and strategy games can also help build long DNA molecules.
   Story time! The Edinburgh Genome Foundry, where I worked a few years, is a platform that sells custom synthetic DNA. Customers email long sequences (ATGCTAC..., typically 10,000 bases or longer) which an automated setup will produce, generally by assembling smaller DNA fragments into bigger ones.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zulko.github.io/bricks_and_scissors/posts/dnaweaver/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-04-08T08:47:11+01:00">
<meta property="article:modified_time" content="2021-04-08T08:47:11+01:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="DNA construction strategies from graph algorithms">
<meta name=twitter:description content="Note: This is a bloggification of these IWBDA 2019 slides on how path-finding tricks used in Google Maps and strategy games can also help build long DNA molecules.
   Story time! The Edinburgh Genome Foundry, where I worked a few years, is a platform that sells custom synthetic DNA. Customers email long sequences (ATGCTAC..., typically 10,000 bases or longer) which an automated setup will produce, generally by assembling smaller DNA fragments into bigger ones.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zulko.github.io/bricks_and_scissors/posts/"},{"@type":"ListItem","position":2,"name":"DNA construction strategies from graph algorithms","item":"https://zulko.github.io/bricks_and_scissors/posts/dnaweaver/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DNA construction strategies from graph algorithms","name":"DNA construction strategies from graph algorithms","description":"Note: This is a bloggification of these IWBDA 2019 slides on how path-finding tricks used in Google Maps and strategy games can also help build long DNA molecules.\n   Story time! The Edinburgh Genome Foundry, where I worked a few years, is a platform that sells custom synthetic DNA. Customers email long sequences (ATGCTAC..., typically 10,000 bases or longer) which an automated setup will produce, generally by assembling smaller DNA fragments into bigger ones.","keywords":["synbio","DNA","assembly","software"],"articleBody":"  Note: This is a bloggification of these IWBDA 2019 slides on how path-finding tricks used in Google Maps and strategy games can also help build long DNA molecules.\n   Story time! The Edinburgh Genome Foundry, where I worked a few years, is a platform that sells custom synthetic DNA. Customers email long sequences (ATGCTAC..., typically 10,000 bases or longer) which an automated setup will produce, generally by assembling smaller DNA fragments into bigger ones.\nThe platform can assemble thousands of DNA fragments per day, but how do you channel enough projects to feed the beast? How do you enable biologists worldwide to order DNA constructs as easily as they would order dinner or a plane trip?\nOne of our first software projects, a collaboration with Autodesk , was a customer portal where users could design DNA sequences and order them from different froundries:\nThe website was sunset by Autodesk before it could become the Skyscanner of large DNA, and while it is open-source we never had the infrastructure nor the bandwidth to pick it up. Customers would just have to design their sequences with classic software like Benchling, SnapGene, or more likely Microsoft Word (no kidding).\nBut the quote generation problem, or “how to automatically analyse a customer’s DNA sequence and determine the cheapest, fastest way our foundry could build it” remained a hot topic. Assessing and planning large DNA construction projects manually can take weeks, and some customers don’t have the patience. This is particularly true for longer sequences, as these can be built in many, many ways.\nFrom parts, from scratch, from snatch How you build long DNA sequences depends on your preferred DNA assembly techniques, which DNA fragments providers you trust, what DNA fragments you already have in stock, what organisms you could snatch DNA from, and how cheap and fast you want the whole project to be.\nParts assembly projects The easiest scenario is when customers require sequences that are made up of standard genetic parts. These parts are often easy to find (laboratories near you may have them in their fridge if you don’t already), easy to replenish miniprep, and designed to easily clip together into a construct. Sometimes this construct is used as a part for a subsequent, higher order construct, and so on until you obtain the desired assembly.\nThis is cheap, reliable, fast (around one day per assembly), and the planning consists mainly in finding the best order in which to assemble the parts, which can be aided by software solutions like RavenCAD :\nSynthesis from scratch DNA sequences that are completely novel can be assembled from the bottom up. You start from oligos, small DNA molecules of 40-100 nucleotides synthesized one nucleotide at a time. From these oligos you assemble bigger fragments (1000 nucleotides), then fuse these fragments into even bigger blocks etc.\nWhole synthetic genomes of hundreds of thousands (and soon millions) of nucleotides are built this way. Each synthesis project has its particularities, and implements custom software to plan the thousands of assembly operations required (which are then performed either by automated biofoundries or by armies of students and postdocs).\nHere is a fully synthetic and re-designed Caulobacter crescentus genome by Christen et al.. Note that they didn’t start from printed oligos, and instead ordered 1,000-nucleotide blocks from a company specialized in DNA printing:\nBit-of-both assembly projects Our customer’s projects were rarely built entirely from parts, or entirely or scratch, but rather from a mix of DNA reuse and de-novo synthesis. A typical example is the assembly of pre-existing genetic parts from a standard library, with a gene that would be synthesized by one of our external vendor:\nSome vendors are cheap (count 100$ for a 1000-nucleotide gene) but will only accept “easy” sequences, others will be up to twice more expensive, but will really try and synthesize anything you throw at them.\nAll vendors have limits on the sequence size they’ll accept, and so we would order the longest sequences in multiple smaller fragments (sometimes from different providers) that would then be fused together, possibly at the same time as the other parts:\nIt’s starting to look like an interesting computational problem! Let’s throw in one more popular cloning technique.\nIf the gene you want is from an organism you have in your freezer (for instance E. coli bacteria), you can easily extract the gene via PCR extraction, by ordering two small oligos that match its starting and ending sequences, and will guide an enzyme to create copies of it from the organism’s chromosome:\nThis method can get you 4,000-nucleotide genetic components for just a few dollars and a day of work! But what if the sequence naturally present is E. coli is only almost the sequence you want, but with two different nucleotides?\nIn that case you would use a protocol called site-directed mutagenesis where you order 6 oligos to create 3 fragments with slighlty altered sequences, and fuse everything together:\nSelecting a stitch Not only can DNA fragments come from many different sources, they can also be fused together in different ways. Here are schematics of Golden Gate Assembly, Gibson Assembly, and LCR assembly, to only show a few:\nThese methods vary in how many sequence fragments they can assemble at once, which sequence patterns will cause problems (repeats, secondary structures, homologies), which fragments and oligos sequences must be ordered, etc.\nSo yeah, it’s complicated The multitude of sources and assembly methods can make the planning of large DNA assemblies a hard combinatorial problem. I’ve seen meetings for complex projects where everyone with DNA wisdom is gathered in a same room, the sequence(s) to build put on display, and it goes a bit like this:\nEven with many experts in the room, errors can be made, and workload estimations can be wrong. So how do you replace this meeting by software?\nStep 1: representing the problem The best way I found to represent DNA assembly problems is supply networks, which show the flow of DNA fragments from the original sources and providers to the final construct. Here is the supply network for “I can build DNA constructs via Golden Gate assembly of fragments either bought from vendor CheapDNA, or assembled from oligos”:\nWhile DNA fragments flow top to bottom in the network, DNA requests flow bottom to top: the Golden Gate assembly station asks CheapDna and Oligo Assembly “I need this fragment, which of you can produce it and for which price? I’ll go with the cheapest.\", and both providers will come back with their best offer. CheapDNA determines the price based on a pricing policy (for instance 10c per basepair), while Oligo Assembly first asks its own provider Oligos.com for oligo prices, before adding the cost of the oligo fusion operation.\nHere are some more detailed schemas of how different sources of DNA may respond to a fragment request:\nSupply network are generally modeled using a Python script (example), but I also made a toy web application (ever a toy) that lets you build a supply network and submit a sequence to build:\nHere are some screenshots of the app’s output, showing a suggested assembly plan and a shopping list of parts and oligos to buy (part sequences are in a separate spreadsheet):\nThe main advantage of supply networks is how easily they can represent common scenarios. Here is “I assemble DNA via Gibson Assembly and I have 3 vendors to buy fragments from”.\nWith the schema above, each DNA fragment may come from a different vendor, which is not ideal (it’s a lot of paperwork!). Here is a variation meaning “I have 3 vendors to choose from, but all fragments will come from the vendor which can deliver all fragments for the lowest total price”.\nHere is “I assemble long DNA molecules from scratch in several steps, starting with oligos I order.\"\nHere is the supply network for site-directed mutagenesis, described earlier:\nFinally, here is “I use yeast recombination to assemble big fragments, which I obtain via E. coli PCR, or by Golden Gate or Gibson Assembly of smaller fragments obtained from DeluxeDNA, CheapDNA, or oligo assembly”. You get the idea.\nSo it is possible to represent the most common DNA assembly problems via networks of DNA suppliers following mostly simple internal logics. The one nodes of this network that will require complex internal logics are assembly stations, who have the central responsibility of decomposing the requested sequence into fragments that will as cheap as possible to produce by their sources. How do they do it?\nStep 2: finding the right cuts Given a set of DNA sources (vendors, libraries, PCR extraction…) and a given sequence to assemble, which sequence fragments should be ordered, and from which sources ? After all, there are trillions of ways of decomposing a sequence into fragments:\nThere have been many approaches to this problem, using deterministic algorithms, genetic algorithms, etc., but these approaches generally explore only a small fraction of the possibilities. The most efficient solution I found consists in representing the question as a graph shortest-path problem. First, take a segment of the sequence, and add whichever flanks required by your assembly method (homologies with neighboring sequences, restriction sites…) to obtain the fragment to order:\nThen submit this fragment to all the suppliers to obtain a best offer. Mark the segment with that price (and remember who the best supplier is):\nDo the same for every subsegment of the sequence, to obtain the decomposition graph of the sequence:\nIn that graph, find the shortest path from the first to the last nucleotide: it corresponds to the optimal sequence decomposition into fragments. All you need at this point is to remember the best supplier for each fragment:\nThis method very easy to code, as most graph libraries implement the Dijkstra shortest-path algorithm. Here is a minimal example in Python (using the Networkx framework) where a sequence is decomposed so that fragments will be either purchased (at 10c per nucleotide) or obtained from the fridge for free:\nimport networkx as nx def decompose_sequence(sequence, free_fragment_sequences, basepair_cost=0.1): def cost(subsequence): if subsequence in free_fragment_sequences: return 0 else: return basepair_cost * len(subsequence) graph_edges = [ (i, j, {\"cost\": cost(sequence[i:j])}) for i in range(len(sequence)) for j in range(i + 2, len(sequence) + 1) ] graph = nx.DiGraph(graph_edges) path = nx.shortest_path(graph, 0, len(sequence), weight='cost') return [ dict(segment=(i, j), sequence=sequence[i: j], cost=graph[i][j]['cost']) for i, j in zip(path, path[1:]) ] decompose_sequence( sequence = \"ATTCTACTAAATTTGCACTCAGAGAGAACCATTA\", free_fragment_sequences = [\"AAATTT\", \"GAGAGA\", \"GGCCC\"] ) # Result: #  [{'segment': (0, 8), 'sequence': 'ATTCTACT', 'cost': 0.8 }, # {'segment': (8, 14), 'sequence': 'AAATTT', 'cost': 0 }, # {'segment': (14, 21), 'sequence': 'GCACTCA', 'cost': 0.7 }, # {'segment': (21, 27), 'sequence': 'GAGAGA', 'cost': 0 }, # {'segment': (27, 33), 'sequence': 'ACCATT', 'cost': 0.6 }] This shortest-path trick is one of my proudest computational stunts, but I can’t be certain to have been the first to use it. California-based DNA vendor Twist Bioscience has been recruiting developers with graph theory skills years ago, and more recently Italy-based Doulix published this tweet which really looks like graph-based assembly optimization (and they may even have nailed circular shortest paths to assemble plasmids!).\nDon’t waste your time on assembly, just focus on your plasmid design. Check out Doulix’s latest cloning algorithm with all new #GibsonAssembly assistant. Just presented at #4Bio #globalengage #synbio #cloning pic.twitter.com/C9499Cls17\n— info@doulix.com (@Doulix_SynthBio) December 5, 2017   Finally, a Github search gave me this project from the University of Washington which also uses shortest path algorithms, and integrates with other lab automation software. It’s a nice tribute to applied maths that different groups through the world came up with the same abstraction of a pretty recent problem.\nCloning constraints as graph operations The great thing with the graph representation of the DNA construction problem is how you can model practical cloning constraints with simple operations:\n “My assembly method doesn’t work with fragments shorter than X or longer than Y”: just remove all graph edges spanning more than Y or less than X.   “This assembly method works badly when the fragment fusion regions contain very low GC or repeated sequences”: remove the graph nodes corresponding to such regions.   “I need to force the junction between two fragments to absolutely happen at a certain location in the sequence, so I can swap parts later”. Simply remove all edges of the graph that go over that location:    “The assembly method works badly when assembly more than 10 parts”: if the shortest path has more than 10 edges, add a constant penalty weight to each edge, and compute the new shortest path, which should have less edges. Increase the penalty if necessary.\n  “Golden Gate assembly overhangs should all be inter-compatible” (read this other article on that subject): If the assembly strabtegy correspondings to the shortest path has DNA fragments with imcompatible overhangs, use a backtracking algorithm (Yen 1971, as implemented in Networkx) to iterate through the 2nd-shortest-path, 3rd, 4th, etc. until one assembly has compatible overhangs.\n  “Oligo assembly only works with an even number of fragments” – I actually don’t have an elegant solution for this one, but here is a stackoverflow suggestion for finding even-edged shortest path via an heavy transformation of the graph.\n  Harder, faster, stronger: the A-star algorithm One bottleneck of the graph representation approach is that large sequences (from tens of thousands of nucleotides) will require to cost millions of edges, which will take a few minutes. This is generally acceptable for foundry operators, given the reward, but too slow to give web customers the instantaneous, flight-booking-like experience that will keep them asking for prices as they tweak their DNA designs.\nA solution to this is A*, another shortest-path algorithm which can just ignore most edges of the graph if they look unlikely to be part to the optimal solution. It may sometimes be wrong, and miss the best path, but it is a very good approximator.\nHere is an illustration (from user user Subh83 on the A* wikipedia page where A* finds a similar path that is only 10% longer path by exploring 50% less edges:\n Dijsktra algorithm A* algorithm       The speed and good approximation make A* a good choice for interactive applications, and it has been used for real-time strategy games such as Age of Empire, which require to move many units through the map without any lag:\nA* is so good at ignoring graph edges because it is fed a particular piece of information from which it will evaluate, at any point of the search, how far it is from its goal. For the illustration above, the information may be the geometric distance to the goal divided by the average terrain speed. If you are looking for the fastest trip in a city, Google Maps will probably use the distance to your goal, divided by the typical speed of the city’s transportation opportunities. To find the cheapest DNA construction strategy, that information will be the number of nucleotides left, times the typical price per-nucleotide price of DNA.\nThe art is to decide what a “typical per-nucleotide price” is. If you pick it too low, the A* algorithm will have practically no advantage over Djikstra (it will be slow), and if you take it too high, A* will assume that any move is cheap, and go for the most obvious ways to build the sequence, even if they are expensive. Say your providers are two companies charging 10c/nucleotide and 20c/nucleotide respectively.\nCutting through the middle, 15c/nucleotide is a good choice of typical price. And indeed, the assembly station running an A* search with this parameter will be more than 10 times faster, and find still find optimal solutions. A lower parameter value provides no speed advantage, and a higher value creates naive and expensive DNA assembly plans:\nFor problems with more sources it can get trickier, but you get the general idea. The important is that when the algorithm finds out that a 5000-nucleotide fragment of the sequence can be obtained virtually for free via PCR, it will understand that it is on a “fast lane” and that there are probably no other way but to use that free source. Let’s come back to this problem:\nAs it turns out, the optimal price heuristic seems to also be ~15c/nucleotide, meaning, in a nutshell “DeluxDNA or oligo assembly are considered expensive, look for alternatives when possible”. With this setting for all stations, computing an assembly strategy for a 50,000-nucleotide sequence with E. coli homologies and a distribution of patterns go from 12 to 0.8 seconds, which is the difference between a long lag and a long click, between slow iterations by trial and error, and real-time price update as you edit your sequence:\nConclusion Fifty years ago, synthesizing a 50-mucleotide bit of DNA was a scientific achievement. Today a high-schooler can order a gene for a few hundred dollars. But for longer sequences we’re not out of the woods yet. It will take time to plan, it will hit your budget, and in some cases the success is not even guaranteed. I’ve seen this being a big factor of project paralysis in Synthetic Biology, with researchers pondering their options, planning their orders for months before taking a leap.\nAdd to this that five years from now, commercial DNA offers, cloning techniques, and even the nature of projects will be different (I didn’t scrape the surface of combinatiorial assembly, multiplexed PCRs, genome editing, and many other subjects I know less about), which makes it a lot of work for software teams to keep up with software tools. All this to say that if you are into algorithms and bioengineering, there should be plenty to do.\n","wordCount":"2940","inLanguage":"en","datePublished":"2021-04-08T08:47:11+01:00","dateModified":"2021-04-08T08:47:11+01:00","author":{"@type":"Person","name":"Zulko"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zulko.github.io/bricks_and_scissors/posts/dnaweaver/"},"publisher":{"@type":"Organization","name":"Bricks and Scissors","logo":{"@type":"ImageObject","url":"https://zulko.github.io/bricks_and_scissors/favicon.ico"}}}</script>
</head>
<body id=top>
<script>window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://zulko.github.io/bricks_and_scissors/ accesskey=h title="Bricks and Scissors (Alt + H)">Bricks and Scissors</a>
<span class=logo-switches>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
DNA construction strategies from graph algorithms
</h1>
<div class=post-meta>April 8, 2021&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Zulko
</div>
</header>
<div class=post-content><hr>
<blockquote>
<p><em><strong>Note:</strong> This is a bloggification of <a href=https://github.com/Edinburgh-Genome-Foundry/egf-shared-documents/blob/master/slideshows/dnaweaver_presentation_iwbda_2019/talk_long.pdf target=_blank>these IWBDA 2019 slides</a> on how path-finding tricks used in Google Maps and strategy games can also help build long DNA molecules.</em></p>
</blockquote>
<hr>
<br>
<p>Story time! The Edinburgh Genome Foundry, where I worked a few years, is a platform that sells custom synthetic DNA. Customers email long sequences (<code>ATGCTAC...</code>, typically 10,000 bases or longer) which an automated setup will produce, generally by assembling smaller DNA fragments into bigger ones.</p>
<p><img src=../../post_assets/dnaweaver/foundry.jpg style="display:block;margin:1.5cm auto" title="Two robots gossiping during a coffee break" width=550></p>
<p>The platform can assemble thousands of DNA fragments per day, but how do you channel enough projects to feed the beast? How do you enable biologists worldwide to order DNA constructs as easily as they would order dinner or a plane trip?</p>
<p>One of our first software projects, a collaboration with <a href=https://www.autodesk.com/ target=_blank> Autodesk</a> , was a customer portal where users could design DNA sequences and order them from different froundries:</p>
<p><img src=../../post_assets/dnaweaver/design_order_4.png style="display:block;margin:1.5cm auto" title="Skyscanner of DNA assembly" width=500></p>
<p>The website was sunset by Autodesk before it could become the Skyscanner of large DNA, and while it is <a href=https://github.com/Autodesk/genetic-constructor-ce target=_blank> open-source</a> we never had the infrastructure nor the bandwidth to pick it up. Customers would just have to design their sequences with classic software like <a href=https://www.benchling.com/ target=_blank> Benchling</a>, <a href=https://www.snapgene.com/ target=_blank>SnapGene</a>, or more likely Microsoft Word (<a href=https://github.com/Edinburgh-Genome-Foundry/crazydoc target=_blank>no kidding</a>).</p>
<p>But the quote generation problem, or <em>&ldquo;how to automatically analyse a customer&rsquo;s DNA sequence and determine the cheapest, fastest way our foundry could build it&rdquo;</em> remained a hot topic. Assessing and planning large DNA construction projects manually can take weeks, and some customers don&rsquo;t have the patience. This is particularly true for longer sequences, as these can be built in many, many ways.</p>
<h2 id=from-parts-from-scratch-from-snatch>From parts, from scratch, from snatch<a hidden class=anchor aria-hidden=true href=#from-parts-from-scratch-from-snatch>#</a></h2>
<p>How you build long DNA sequences depends on your preferred DNA assembly techniques, which DNA fragments providers you trust, what DNA fragments you already have in stock, what organisms you could snatch DNA from, and how cheap and fast you want the whole project to be.</p>
<h3 id=parts-assembly-projects>Parts assembly projects<a hidden class=anchor aria-hidden=true href=#parts-assembly-projects>#</a></h3>
<p>The easiest scenario is when customers require sequences that are made up of <em>standard genetic parts</em>. These parts are often easy to find (laboratories near you may have them in their fridge if you don&rsquo;t already), easy to replenish miniprep, and designed to easily clip together into a construct. Sometimes this construct is used as a part for a subsequent, higher order construct, and so on until you obtain the desired assembly.</p>
<p><img src=../../post_assets/dnaweaver/basic_parts_assembly.png style="display:block;margin:.5cm auto" title='"Just like legos"' width=350></p>
<p>This is cheap, reliable, fast (around one day per assembly), and the planning consists mainly in finding the best order in which to assemble the parts, which can be aided by software solutions like <a target=_blank href=https://www.cidarlab.org/raven> RavenCAD </a>:</p>
<p><img src=../../post_assets/dnaweaver/ravencad.png style="display:block;margin:1cm auto" width=650></p>
<h3 id=synthesis-from-scratch>Synthesis from scratch<a hidden class=anchor aria-hidden=true href=#synthesis-from-scratch>#</a></h3>
<p>DNA sequences that are completely novel can be assembled from the bottom up. You start from <em>oligos</em>, small DNA molecules of 40-100 nucleotides synthesized one nucleotide at a time. From these oligos you assemble bigger fragments (1000 nucleotides), then fuse these fragments into even bigger blocks etc.</p>
<p><img src=../../post_assets/dnaweaver/basic_from_scratch.png style="display:block;margin:1cm auto" width=400></p>
<p>Whole synthetic genomes of hundreds of thousands (and soon millions) of nucleotides are built this way. Each synthesis project has its particularities, and implements custom software to plan the thousands of assembly operations required (which are then performed either by automated biofoundries or by armies of students and postdocs).</p>
<p>Here is a fully synthetic and re-designed <em>Caulobacter crescentus</em> genome by <a href=https://pubmed.ncbi.nlm.nih.gov/28531174/ target=_blank>Christen et al.</a>. Note that they didn&rsquo;t start from printed oligos, and instead ordered 1,000-nucleotide blocks from a company specialized in DNA printing:</p>
<p><img src=../../post_assets/dnaweaver/genome_caligrapher.png style="display:block;margin:0 auto 1cm" width=450></p>
<h3 id=bit-of-both-assembly-projects>Bit-of-both assembly projects<a hidden class=anchor aria-hidden=true href=#bit-of-both-assembly-projects>#</a></h3>
<p>Our customer&rsquo;s projects were rarely built entirely from parts, or entirely or scratch, but rather from a mix of DNA reuse and de-novo synthesis. A typical example is the assembly of pre-existing genetic parts from a standard library, with a gene that would be synthesized by one of our external vendor:</p>
<p><img src=../../post_assets/dnaweaver/library_and_vendors_mix.png style="display:block;margin:1.5cm auto" width=500></p>
<p>Some vendors are cheap (count 100$ for a 1000-nucleotide gene) but will only accept &ldquo;easy&rdquo; sequences, others will be up to twice more expensive, but will really try and synthesize anything you throw at them.</p>
<p>All vendors have limits on the sequence size they&rsquo;ll accept, and so we would order the longest sequences in multiple smaller fragments (sometimes from different providers) that would then be fused together, possibly at the same time as the other parts:</p>
<p><img src=../../post_assets/dnaweaver/library_and_vendors_mix_fragments.png style="display:block;margin:1.5cm auto" width=500></p>
<p>It&rsquo;s starting to look like an interesting computational problem! Let&rsquo;s throw in one more popular cloning technique.</p>
<p>If the gene you want is from an organism you have in your freezer (for instance <em>E. coli</em> bacteria), you can easily extract the gene via <em>PCR extraction</em>, by ordering two small oligos that match its starting and ending sequences, and will guide an enzyme to create copies of it from the organism&rsquo;s chromosome:</p>
<p><img src=../../post_assets/dnaweaver/basic_pcr.png style="display:block;margin:1cm auto" width=580></p>
<p>This method can get you 4,000-nucleotide genetic components for just a few dollars and a day of work! But what if the sequence naturally present is E. coli is only <em>almost</em> the sequence you want, but with two different nucleotides?</p>
<p><img src=../../post_assets/dnaweaver/the_sequence_we_need.png style="display:block;margin:1cm auto" title="The sequence you need, and the sequence you deserve" width=540></p>
<p>In that case you would use a protocol called <em>site-directed mutagenesis</em> where you order 6 oligos to create 3 fragments with slighlty altered sequences, and fuse everything together:</p>
<p><img src=../../post_assets/dnaweaver/basic_site_directed_mutagenesis.png style="display:block;margin:0 auto" width=630></p>
<h3 id=selecting-a-stitch>Selecting a stitch<a hidden class=anchor aria-hidden=true href=#selecting-a-stitch>#</a></h3>
<p>Not only can DNA fragments come from many different sources, they can also be fused together in different ways. Here are schematics of Golden Gate Assembly, Gibson Assembly, and LCR assembly, to only show a few:</p>
<p><img src=../../post_assets/dnaweaver/assembly_methods.png style="display:block;margin:2cm auto" width=500></p>
<p>These methods vary in how many sequence fragments they can assemble at once, which sequence patterns will cause problems (repeats, secondary structures, homologies), which fragments and oligos sequences must be ordered, etc.</p>
<h3 id=so-yeah-its-complicated>So yeah, it&rsquo;s complicated<a hidden class=anchor aria-hidden=true href=#so-yeah-its-complicated>#</a></h3>
<p>The multitude of sources and assembly methods can make the planning of large DNA assemblies a hard combinatorial problem. I&rsquo;ve seen meetings for complex projects where everyone with DNA wisdom is gathered in a same room, the sequence(s) to build put on display, and it goes a bit like this:</p>
<p><img src=../../post_assets/dnaweaver/elrond.jpg style="display:block;margin:2cm auto" width=450 title="Hey look! I can't meme."></p>
<p>Even with many experts in the room, errors can be made, and workload estimations can be wrong. So how do you replace this meeting by software?</p>
<h2 id=step-1-representing-the-problem>Step 1: representing the problem<a hidden class=anchor aria-hidden=true href=#step-1-representing-the-problem>#</a></h2>
<p>The best way I found to represent DNA assembly problems is <em>supply networks</em>, which show the flow of DNA fragments from the original sources and providers to the final construct. Here is the supply network for <em>&ldquo;I can build DNA constructs via Golden Gate assembly of fragments either bought from vendor CheapDNA, or assembled from oligos&rdquo;</em>:</p>
<p><img src=../../post_assets/dnaweaver/simple_supply_network.png style="display:block;margin:1cm auto 2cm" width=200></p>
<p>While DNA fragments flow top to bottom in the network, DNA requests flow bottom to top: the Golden Gate assembly station asks <em>CheapDna</em> and <em>Oligo Assembly</em> <em>&ldquo;I need this fragment, which of you can produce it and for which price? I&rsquo;ll go with the cheapest."</em>, and both providers will come back with their best offer. CheapDNA determines the price based on a pricing policy (for instance 10c per basepair), while Oligo Assembly first asks its own provider <em>Oligos.com</em> for oligo prices, before adding the cost of the oligo fusion operation.</p>
<p>Here are some more detailed schemas of how different sources of DNA may respond to a fragment request:</p>
<p><img src=../../post_assets/dnaweaver/sources/parts_library.png style="display:block;margin:1cm auto 2cm" width=450>
<img src=../../post_assets/dnaweaver/sources/dna_vendor.png style="display:block;margin:1cm auto 2cm" width=450>
<img src=../../post_assets/dnaweaver/sources/PCR_extraction.png style="display:block;margin:1cm auto 2cm" width=450>
<img src=../../post_assets/dnaweaver/sources/assembly_station.png style="display:block;margin:1cm auto 2cm" width=450></p>
<p>Supply network are generally modeled using a Python script (<a href=https://github.com/Edinburgh-Genome-Foundry/galaxy_synbiocad_dnaweaver/blob/master/methods/generate_supply_network.py target=_blank>example</a>), but I also made a toy <a target=_blank href=https://dnaweaver.genomefoundry.org/#/>web application</a> (ever a toy) that lets you build a supply network and submit a sequence to build:</p>
<p><img src=../../post_assets/dnaweaver/dna_weaver_demo.gif style="display:block;margin:1cm auto 2cm" width=350></p>
<p>Here are some screenshots of the app&rsquo;s output, showing a suggested assembly plan and a shopping list of parts and oligos to buy (part sequences are in a separate spreadsheet):</p>
<p><img src=../../post_assets/dnaweaver/dnaweaver_reports.png style="display:block;margin:1cm auto 2cm;width:700px"></p>
<p>The main advantage of supply networks is how easily they can represent common scenarios. Here is <em>&ldquo;I assemble DNA via Gibson Assembly and I have 3 vendors to buy fragments from&rdquo;</em>.</p>
<p><img src=../../post_assets/dnaweaver/supply_network_examples/multi_vendor.png style="display:block;margin:1cm auto 2cm" width=300></p>
<p>With the schema above, each DNA fragment may come from a different vendor, which is not ideal (it&rsquo;s a lot of paperwork!). Here is a variation meaning <em>&ldquo;I have 3 vendors to choose from, but all fragments will come from the vendor which can deliver all fragments for the lowest total price&rdquo;</em>.</p>
<p><img src=../../post_assets/dnaweaver/supply_network_examples/single_provider.png style="display:block;margin:1cm auto 2cm" width=300></p>
<p>Here is <em>&ldquo;I assemble long DNA molecules from scratch in several steps, starting with oligos I order."</em></p>
<p><img src=../../post_assets/dnaweaver/supply_network_examples/synthesis.png style="display:block;margin:1cm auto 2cm" width=300></p>
<p>Here is the supply network for site-directed mutagenesis, described earlier:</p>
<p><img src=../../post_assets/dnaweaver/supply_network_examples/site_directed_mutagenesis.png style="display:block;margin:1cm auto 2cm" width=300></p>
<p>Finally, here is <em>&ldquo;I use yeast recombination to assemble big fragments, which I obtain via E. coli PCR, or by Golden Gate or Gibson Assembly of smaller fragments obtained from DeluxeDNA, CheapDNA, or oligo assembly&rdquo;</em>. You get the idea.</p>
<p><img src=../../post_assets/dnaweaver/supply_network_examples/complex.png style="display:block;margin:1cm auto 2cm" width=350></p>
<p>So it is possible to represent the most common DNA assembly problems via networks of DNA suppliers following mostly simple internal logics. The one nodes of this network that will require complex internal logics are assembly stations, who have the central responsibility of decomposing the requested sequence into fragments that will as cheap as possible to produce by their sources. How do they do it?</p>
<h2 id=step-2-finding-the-right-cuts>Step 2: finding the right cuts<a hidden class=anchor aria-hidden=true href=#step-2-finding-the-right-cuts>#</a></h2>
<p>Given a set of DNA sources (vendors, libraries, PCR extraction&mldr;) and a given sequence to assemble, which sequence fragments should be ordered, and from which sources ? After all, there are trillions of ways of decomposing a sequence into fragments:</p>
<p><img src=../../post_assets/dnaweaver/shortest_path/0_where_to_cut.png style="display:block;margin:1cm auto 2cm;width:550px"></p>
<p>There have been many approaches to this problem, using deterministic algorithms, genetic algorithms, etc., but these approaches generally explore only a small fraction of the possibilities. The most efficient solution I found consists in representing the question as a graph shortest-path problem. First, take a segment of the sequence, and add whichever flanks required by your assembly method (homologies with neighboring sequences, restriction sites&mldr;) to obtain the fragment to order:</p>
<p><img src=../../post_assets/dnaweaver/shortest_path/1_fragment_sequence.png style="display:block;margin:1cm auto 2cm;width:550px"></p>
<p>Then submit this fragment to all the suppliers to obtain a best offer. Mark the segment with that price (and remember who the best supplier is):</p>
<p><img src=../../post_assets/dnaweaver/shortest_path/2_best_price.png style="display:block;margin:1cm auto 2cm;width:550px"></p>
<p>Do the same for every subsegment of the sequence, to obtain the <em>decomposition graph</em> of the sequence:</p>
<p><img src=../../post_assets/dnaweaver/shortest_path/3_assembly_graph.png style="display:block;margin:1cm auto 2cm;width:550px"></p>
<p>In that graph, find the shortest path from the first to the last nucleotide: it corresponds to the optimal sequence decomposition into fragments. All you need at this point is to remember the best supplier for each fragment:</p>
<p><img src=../../post_assets/dnaweaver/shortest_path/4_shortest_path.png style="display:block;margin:1cm auto 2cm;width:550px"></p>
<p>This method very easy to code, as most graph libraries implement the Dijkstra shortest-path algorithm. Here is a minimal example in Python (using the <a href=https://networkx.org/ target=_blank>Networkx</a> framework) where a sequence is decomposed so that fragments will be either purchased (at 10c per nucleotide) or obtained from the fridge for free:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> networkx <span style=color:#66d9ef>as</span> nx

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>decompose_sequence</span>(sequence, free_fragment_sequences, basepair_cost<span style=color:#f92672>=</span><span style=color:#ae81ff>0.1</span>):
    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>cost</span>(subsequence):
        <span style=color:#66d9ef>if</span> subsequence <span style=color:#f92672>in</span> free_fragment_sequences:
            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
        <span style=color:#66d9ef>else</span>:
            <span style=color:#66d9ef>return</span> basepair_cost <span style=color:#f92672>*</span> len(subsequence)
    graph_edges <span style=color:#f92672>=</span> [
        (i, j, {<span style=color:#e6db74>&#34;cost&#34;</span>: cost(sequence[i:j])})
        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(sequence))
        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>, len(sequence) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
    ]
    graph <span style=color:#f92672>=</span> nx<span style=color:#f92672>.</span>DiGraph(graph_edges)
    path <span style=color:#f92672>=</span> nx<span style=color:#f92672>.</span>shortest_path(graph, <span style=color:#ae81ff>0</span>, len(sequence), weight<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;cost&#39;</span>)
    <span style=color:#66d9ef>return</span> [
        dict(segment<span style=color:#f92672>=</span>(i, j), sequence<span style=color:#f92672>=</span>sequence[i: j], cost<span style=color:#f92672>=</span>graph[i][j][<span style=color:#e6db74>&#39;cost&#39;</span>])
        <span style=color:#66d9ef>for</span> i, j <span style=color:#f92672>in</span> zip(path, path[<span style=color:#ae81ff>1</span>:])
    ]

decompose_sequence(
    sequence <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ATTCTACTAAATTTGCACTCAGAGAGAACCATTA&#34;</span>,
    free_fragment_sequences <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;AAATTT&#34;</span>, <span style=color:#e6db74>&#34;GAGAGA&#34;</span>, <span style=color:#e6db74>&#34;GGCCC&#34;</span>]
)
<span style=color:#75715e># Result:</span>
<span style=color:#75715e># &gt;&gt;&gt; [{&#39;segment&#39;: (0, 8),   &#39;sequence&#39;: &#39;ATTCTACT&#39;, &#39;cost&#39;: 0.8 },</span>
<span style=color:#75715e>#      {&#39;segment&#39;: (8, 14),  &#39;sequence&#39;: &#39;AAATTT&#39;,   &#39;cost&#39;: 0   },</span>
<span style=color:#75715e>#      {&#39;segment&#39;: (14, 21), &#39;sequence&#39;: &#39;GCACTCA&#39;,  &#39;cost&#39;: 0.7 },</span>
<span style=color:#75715e>#      {&#39;segment&#39;: (21, 27), &#39;sequence&#39;: &#39;GAGAGA&#39;,   &#39;cost&#39;: 0   },</span>
<span style=color:#75715e>#      {&#39;segment&#39;: (27, 33), &#39;sequence&#39;: &#39;ACCATT&#39;,   &#39;cost&#39;: 0.6 }]</span>
</code></pre></div><p>This shortest-path trick is one of my proudest computational stunts, but I can&rsquo;t be certain to have been the first to use it. California-based DNA vendor Twist Bioscience has been <a target=_blank href=https://www.smartrecruiters.com/TwistBioscience/84826182-python-software-engineer-algorithm>recruiting developers with graph theory skills</a> years ago, and more recently Italy-based Doulix published this tweet which really looks like graph-based assembly optimization (and they may even have nailed circular shortest paths to assemble plasmids!).</p>
<div style="width:500px;max-width:100%;margin:1.5cm auto"><blockquote class=twitter-tweet><p lang=en dir=ltr>Don’t waste your time on assembly, just focus on your plasmid design. Check out Doulix’s latest cloning algorithm with all new <a href="https://twitter.com/hashtag/GibsonAssembly?src=hash&ref_src=twsrc%5Etfw">#GibsonAssembly</a> assistant. Just presented at <a href="https://twitter.com/hashtag/4Bio?src=hash&ref_src=twsrc%5Etfw">#4Bio</a> <a href="https://twitter.com/hashtag/globalengage?src=hash&ref_src=twsrc%5Etfw">#globalengage</a> <a href="https://twitter.com/hashtag/synbio?src=hash&ref_src=twsrc%5Etfw">#synbio</a> <a href="https://twitter.com/hashtag/cloning?src=hash&ref_src=twsrc%5Etfw">#cloning</a> <a href=https://t.co/C9499Cls17>pic.twitter.com/C9499Cls17</a></p>&mdash; info@doulix.com (@Doulix_SynthBio) <a href="https://twitter.com/Doulix_SynthBio/status/938068271986823168?ref_src=twsrc%5Etfw">December 5, 2017</a></blockquote>
<script async src=https://platform.twitter.com/widgets.js></script>
</div>
<p>Finally, a Github search gave me <a target=_blank href=https://github.com/jvrana/DASi-DNA-Design>this project</a> from the University of Washington which also uses shortest path algorithms, and integrates with other lab automation software. It&rsquo;s a nice tribute to applied maths that different groups through the world came up with the same abstraction of a pretty recent problem.</p>
<h3 id=cloning-constraints-as-graph-operations>Cloning constraints as graph operations<a hidden class=anchor aria-hidden=true href=#cloning-constraints-as-graph-operations>#</a></h3>
<p>The great thing with the graph representation of the DNA construction problem is how you can model practical cloning constraints with simple operations:</p>
<ul>
<li><em>&ldquo;My assembly method doesn&rsquo;t work with fragments shorter than X or longer than Y&rdquo;</em>: just remove all graph edges spanning more than Y or less than X.</li>
</ul>
<p><img src=../../post_assets/dnaweaver/graph-operations/fragment_size.png style="display:block;margin:1cm auto 2cm;width:550px"></p>
<ul>
<li><em>&ldquo;This assembly method works badly when the fragment fusion regions contain very low GC or repeated sequences&rdquo;</em>: remove the graph nodes corresponding to such regions.</li>
</ul>
<p><img src=../../post_assets/dnaweaver/graph-operations/avoid_region.png style="display:block;margin:1cm auto 2cm;width:550px"></p>
<ul>
<li><em>&ldquo;I need to force the junction between two fragments to absolutely happen at a certain location in the sequence, so I can swap parts later&rdquo;</em>. Simply remove all edges of the graph that go over that location:</li>
</ul>
<p><img src=../../post_assets/dnaweaver/graph-operations/force_location.png style="display:block;margin:1cm auto 2cm;width:550px"></p>
<ul>
<li>
<p><em>&ldquo;The assembly method works badly when assembly more than 10 parts&rdquo;</em>: if the shortest path has more than 10 edges, add a constant penalty weight to each edge, and compute the new shortest path, which should have less edges. Increase the penalty if necessary.</p>
</li>
<li>
<p><em>&ldquo;Golden Gate assembly overhangs should all be inter-compatible&rdquo;</em> (read <a target=_blank href=https://zulko.github.io/bricks_and_scissors/posts/overhangs/>this other article on that subject</a>): If the assembly strabtegy correspondings to the shortest path has DNA fragments with imcompatible overhangs, use a backtracking algorithm (Yen 1971, as <a target=_blank href=https://networkx.org/documentation/networkx-1.10/reference/generated/networkx.algorithms.simple_paths.shortest_simple_paths.html#id2>implemented in Networkx</a>) to iterate through the 2nd-shortest-path, 3rd, 4th, etc. until one assembly has compatible overhangs.</p>
</li>
<li>
<p><em>&ldquo;Oligo assembly only works with an even number of fragments&rdquo;</em> &ndash; I actually don&rsquo;t have an elegant solution for this one, but <a href=https://stackoverflow.com/questions/32722448/shortest-path-with-even-number-of-edges target=_blank>here is a stackoverflow suggestion</a> for finding even-edged shortest path via an heavy transformation of the graph.</p>
</li>
</ul>
<h3 id=harder-faster-stronger-the-a-star-algorithm>Harder, faster, <del>stronger</del>: the A-star algorithm<a hidden class=anchor aria-hidden=true href=#harder-faster-stronger-the-a-star-algorithm>#</a></h3>
<p>One bottleneck of the graph representation approach is that large sequences (from tens of thousands of nucleotides) will require to cost millions of edges, which will take a few minutes. This is generally acceptable for foundry operators, given the reward, but too slow to give web customers the instantaneous, flight-booking-like experience that will keep them asking for prices as they tweak their DNA designs.</p>
<p>A solution to this is <em>A*</em>, another shortest-path algorithm which can just ignore most edges of the graph if they look unlikely to be part to the optimal solution. It may sometimes be wrong, and miss the best path, but it is a very good approximator.</p>
<p>Here is an illustration (from user user <a target=blank href="https://en.wikipedia.org/wiki/User:Subh83?rdfrom=commons:User:Subh83">Subh83</a> on the <a href=https://en.wikipedia.org/wiki/A*_search_algorithm target=_blank>A* wikipedia page</a> where <em>A*</em> finds a similar path that is only 10% longer path by exploring 50% less edges:</p>
<table style="display:block;margin:4em auto;width:500px;max-width:100%">
<tr>
<th style=text-align:center>Dijsktra algorithm</th>
<th style=text-align:center>A* algorithm</th>
</tr>
<tr>
<td style=width:50%>
<img src=https://upload.wikimedia.org/wikipedia/commons/5/5d/Astar_progress_animation.gif style="border:1px solid #ddd">
</td>
<td style=width:50%>
<img src=https://upload.wikimedia.org/wikipedia/commons/8/85/Weighted_A_star_with_eps_5.gif style="border:1px solid #ddd">
</td>
</tr>
</table>
<p>The speed and good approximation make A* a good choice for interactive applications, and it has been used for real-time strategy games such as Age of Empire, which require to move many units through the map without any lag:</p>
<p><img src=../../post_assets/dnaweaver/a_star/aoe.jpeg style="display:block;margin:2cm auto;width:550px"></p>
<p>A* is so good at ignoring graph edges because it is fed a particular piece of information from which it will evaluate, at any point of the search, how far it is from its goal. For the illustration above, the information may be the geometric distance to the goal divided by the average terrain speed. If you are looking for the fastest trip in a city, Google Maps will probably use the distance to your goal, divided by the typical speed of the city&rsquo;s transportation opportunities. To find the cheapest DNA construction strategy, that information will be the number of nucleotides left, times the typical price per-nucleotide price of DNA.</p>
<p>The art is to decide what a &ldquo;typical per-nucleotide price&rdquo; is. If you pick it too low, the A* algorithm will have practically no advantage over Djikstra (it will be slow), and if you take it too high, A* will assume that any move is cheap, and go for the most obvious ways to build the sequence, even if they are expensive. Say your providers are two companies charging 10c/nucleotide and 20c/nucleotide respectively.</p>
<p><img src=../../post_assets/dnaweaver/supply_network_examples/two_vendors.png style="display:block;margin:2cm auto;width:280px"></p>
<p>Cutting through the middle, 15c/nucleotide is a good choice of typical price. And indeed, the assembly station running an A* search with this parameter will be more than 10 times faster, and find still find optimal solutions. A lower parameter value provides no speed advantage, and a higher value creates naive and expensive DNA assembly plans:</p>
<p><img src=../../post_assets/dnaweaver/a_star/two_vendors_results.png style="display:block;margin:1cm auto 2cm" width=600></p>
<p>For problems with more sources it can get trickier, but you get the general idea. The important is that when the algorithm finds out that a 5000-nucleotide fragment of the sequence can be obtained virtually for free via PCR, it will understand that it is on a &ldquo;fast lane&rdquo; and that there are probably no other way but to use that free source. Let&rsquo;s come back to this problem:</p>
<p><img src=../../post_assets/dnaweaver/supply_network_examples/complex.png style="display:block;margin:1cm auto 2cm" width=350></p>
<p>As it turns out, the optimal price heuristic seems to also be ~15c/nucleotide, meaning, in a nutshell <em>&ldquo;DeluxDNA or oligo assembly are considered expensive, look for alternatives when possible&rdquo;</em>. With this setting for all stations, computing an assembly strategy for a 50,000-nucleotide sequence with E. coli homologies and a distribution of patterns go from 12 to 0.8 seconds, which is the difference between a long lag and a long click, between slow iterations by trial and error, and real-time price update as you edit your sequence:</p>
<p><img src=../../post_assets/dnaweaver/a_star/complex_results.png style="display:block;margin:1cm auto 2cm" width=650></p>
<h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2>
<p>Fifty years ago, synthesizing a 50-mucleotide bit of DNA was a scientific achievement. Today a high-schooler can order a gene for a few hundred dollars. But for longer sequences we&rsquo;re not out of the woods yet. It will take time to plan, it will hit your budget, and in some cases the success is not even guaranteed. I&rsquo;ve seen this being a big factor of project paralysis in Synthetic Biology, with researchers pondering their options, planning their orders for months before taking a leap.</p>
<p>Add to this that five years from now, commercial DNA offers, cloning techniques, and even the nature of projects will be different (I didn&rsquo;t scrape the surface of combinatiorial assembly, multiplexed PCRs, genome editing, and many other subjects I know less about), which makes it a lot of work for software teams to keep up with software tools. All this to say that if you are into algorithms and bioengineering, there should be plenty to do.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://zulko.github.io/bricks_and_scissors/tags/synbio/>synbio</a></li>
<li><a href=https://zulko.github.io/bricks_and_scissors/tags/dna/>DNA</a></li>
<li><a href=https://zulko.github.io/bricks_and_scissors/tags/assembly/>assembly</a></li>
<li><a href=https://zulko.github.io/bricks_and_scissors/tags/software/>software</a></li>
</ul>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share DNA construction strategies from graph algorithms on twitter" href="https://twitter.com/intent/tweet/?text=DNA%20construction%20strategies%20from%20graph%20algorithms&url=https%3a%2f%2fzulko.github.io%2fbricks_and_scissors%2fposts%2fdnaweaver%2f&hashtags=synbio%2cDNA%2cassembly%2csoftware"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share DNA construction strategies from graph algorithms on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzulko.github.io%2fbricks_and_scissors%2fposts%2fdnaweaver%2f&title=DNA%20construction%20strategies%20from%20graph%20algorithms&summary=DNA%20construction%20strategies%20from%20graph%20algorithms&source=https%3a%2f%2fzulko.github.io%2fbricks_and_scissors%2fposts%2fdnaweaver%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share DNA construction strategies from graph algorithms on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzulko.github.io%2fbricks_and_scissors%2fposts%2fdnaweaver%2f&title=DNA%20construction%20strategies%20from%20graph%20algorithms"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share DNA construction strategies from graph algorithms on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzulko.github.io%2fbricks_and_scissors%2fposts%2fdnaweaver%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share DNA construction strategies from graph algorithms on whatsapp" href="https://api.whatsapp.com/send?text=DNA%20construction%20strategies%20from%20graph%20algorithms%20-%20https%3a%2f%2fzulko.github.io%2fbricks_and_scissors%2fposts%2fdnaweaver%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share DNA construction strategies from graph algorithms on telegram" href="https://telegram.me/share/url?text=DNA%20construction%20strategies%20from%20graph%20algorithms&url=https%3a%2f%2fzulko.github.io%2fbricks_and_scissors%2fposts%2fdnaweaver%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://zulko.github.io/bricks_and_scissors/>Bricks and Scissors</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/bricks_and_scissors/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
</body>
</html>