<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Strange dominos: the fun and perils of DNA overhang design | Bricks and Scissors</title><meta name=keywords content><meta name=description content="Note: I simplified technical terms and details whenever possible to keep this post focused on the design problems and accessible to a larger audience.
 If you want to stitch more than 2 bits of DNA together, the most popular method these days is probably Golden Gate Assembly. In a nutshell, you mix DNA fragments in a tube where enzymes will cut their flanks to create overhangs (also called sticky ends), then fuse the overhangs together to form the desired DNA construct:"><meta name=author content="Zulko"><link rel=canonical href=http://example.org/posts/overhangs/><link href=/assets/css/stylesheet.min.d85457619e67d31b97f40ed67c71b5efe0b52508ba759e5a9da0760afd6707db.css integrity="sha256-2FRXYZ5n0xuX9A7WfHG17+C1JQi6dZ5anaB2Cv1nB9s=" rel="preload stylesheet" as=style><link rel=icon href=http://example.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://example.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://example.org/favicon-32x32.png><link rel=apple-touch-icon href=http://example.org/apple-touch-icon.png><link rel=mask-icon href=http://example.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><meta property="og:title" content="Strange dominos: the fun and perils of DNA overhang design"><meta property="og:description" content="Note: I simplified technical terms and details whenever possible to keep this post focused on the design problems and accessible to a larger audience.
 If you want to stitch more than 2 bits of DNA together, the most popular method these days is probably Golden Gate Assembly. In a nutshell, you mix DNA fragments in a tube where enzymes will cut their flanks to create overhangs (also called sticky ends), then fuse the overhangs together to form the desired DNA construct:"><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/posts/overhangs/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-08T08:47:11+01:00"><meta property="article:modified_time" content="2021-04-08T08:47:11+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Strange dominos: the fun and perils of DNA overhang design"><meta name=twitter:description content="Note: I simplified technical terms and details whenever possible to keep this post focused on the design problems and accessible to a larger audience.
 If you want to stitch more than 2 bits of DNA together, the most popular method these days is probably Golden Gate Assembly. In a nutshell, you mix DNA fragments in a tube where enzymes will cut their flanks to create overhangs (also called sticky ends), then fuse the overhangs together to form the desired DNA construct:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://example.org/posts/"},{"@type":"ListItem","position":2,"name":"Strange dominos: the fun and perils of DNA overhang design","item":"http://example.org/posts/overhangs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Strange dominos: the fun and perils of DNA overhang design","name":"Strange dominos: the fun and perils of DNA overhang design","description":"Note: I simplified technical terms and details whenever possible to keep this post focused on the design problems and accessible to a larger audience.\n If you want to stitch more than 2 bits of DNA together, the most popular method these days is probably Golden Gate Assembly. In a nutshell, you mix DNA fragments in a tube where enzymes will cut their flanks to create overhangs (also called sticky ends), then fuse the overhangs together to form the desired DNA construct:","keywords":[],"articleBody":" Note: I simplified technical terms and details whenever possible to keep this post focused on the design problems and accessible to a larger audience.\n If you want to stitch more than 2 bits of DNA together, the most popular method these days is probably Golden Gate Assembly. In a nutshell, you mix DNA fragments in a tube where enzymes will cut their flanks to create overhangs (also called sticky ends), then fuse the overhangs together to form the desired DNA construct:\nHow do we know that the DNA parts will assemble in the expected order A-B-C-D, and not C-A-B-D or D-A-C-B ? This is because their DNA sequences are designed so that the 4 nucleotides at the end of each part match the 4 nucleotides at start of the next part, like in a game of dominos:\nLet’s have a closer look at Parts A and B. Each has two strands, with the lower strand being the complementary of the upper one (“T” complements “A”, and “G” complements “C”):\nWhen the flank-cutting enzyme cuts the right flank of Part A, it leaves an overhang of four “bare” nucleotides on the lower strand. When it cuts the left flank of Part B, it leaves another overhang, this time on the upper strand:\nThe two ends are perfectly complementary and will be fused to form a single DNA molecule:\nBioengineers can assemble many parts at once using this method – typically 10, 20, or even 30+ parts for the most ambitious projects. But as the number of parts increases, so does the difficulty of finding overhang sequences that play well together.\nRules of the game Throughout the DNA assembly protocol, several copies of each part are freely floating around in the assembly mix:\nOne thing we really want to avoid here is the accidental fusion of parts that were not meant to fuse together, which would create “monster” DNA molecules and prevent the formation of the desired construct. To this end, a few logical rules must be observed.\nDesign rule #1\nDon’t use the same overhang sequence for different part fusions. If the overhang that fuses Part A to B is the same that fuses Part C to D, then two varieties of constructs will be formed, one of which is missing parts B and C. Yikes!\nDesign rule #2\nBeware of reverse-complementary overhangs! In the example below, each fusion is using a different overhang sequence, which looks great. But notice that the right overhang of Part C, once flipped over, is actually complementary to the right overhang of Part A:\nThis is bad because many copies of Parts A and C will be lost in this useless fusion. Other copies of the parts may still assemble in the right order to produce the expected construct, but the probability of success will be decreased.\nDesign rule #3\nDon’t use overhang sequences that are their own reverse-complements. For instance if a part has a CATG overhang then different copies of this part can fuse together, resulting here again in a waste of fragments and lower assembly success rates.\nPop quiz! Problem 1\nAccording to the rules above, which letter should replace the X?\nProblem 2\nIs this overhang set valid? List the reasons why not.\nProblem 3\nLet’s throw some real-world shade! What would you improve in the overhang design of the Ecoflex bacterial engineering standard? (you don’t need to understand the figures to answer, simply look at the overhang sequences).\nStill too easy?\nIf these small examples made you hesitate for a few seconds, imagine how it feels to design a collection of 20+ overhangs from scratch, where checking the compatibility of all overhangs and their reverse-complements takes hundreds of pair-wise comparisons. After hours (if not days) of careful design, you may still make a few mistakes that will end up costing you weeks of work and thousands of dollars down the line! But wait, it gets worse.\nAdvanced rules for advanced players Real-life DNA assembly projects generally come with their own extra constraints and cave-ats. This section will be a bit more technical, but you can also just glance over and head to the next section on computational resolution.\nExtra rule #1\nSome overhang sequences can be imposed. This typically happens when you already have genetic parts in the fridge that use overhangs ATGC, AATC and GGCA, and you want the next overhangs you design to be compatible with these, so that old and new parts can be assembled in the same constructs.\nOther constraints arise when designing overhangs that will appear at biologically significant locations of the final construct. For instance, in the Phytobrick standard for plant engineering, the DNA parts represent different functional modules of a same gene, with one part encoding a protein, and other parts encoding flanking “tags” (which are biological markers that will send a signal to the cell or the biologist):\nNotice that the second overhang AATG is at the very beginning of a coding sequence, which is why it contains ATG, the sequence of the Methionine start codon. In the next overhang, AGCC, the GCC codes for Alanine, a very small amino-acid commonly used in “chains” linking proteins and tags together. Likewise , TCG in the next overhang codes for Serine, another small amino-acid used in chains. All other overhang sequences in the standard (not shown here) have therefore had to be designed to be compatible with these imposed sequences.\nExtra rule #2\nNo scars! In the most flexible bioengineering projects, you are allowed to add a few nucleotides here and therein the desired sequences to make them easier to assemble from parts. These added nucleotides with no function other than to enable construction are called “assembly scars”.\nIn more demanding bioengineering projects, the desired sequences are so biologically significant and tightly designed that they absolutely cannot be modified – they don’t allow scars. For your assembly, this means that the overhang sequences must be part of the desired final construct sequence:\nThis constraint still leaves some choice in the overhang sequences. For instance we could decide that the first fragment should fuse with the second fragment somewhere in a certain 6-nucleotide region, which gives us 3 options depending on where exactly the fusion occurs:\nEach overhang of the assembly will be picked from a different region of the final sequence, and so will have its own set of options, making the design overhang problem look like this:\nThe example above is a bit underwhelming, but biologists have managed some really impressive scarless assemblies: the schema below describes how Tsuge et al., (2015) assembled a whole phage virus genome of ~50,000 nucleotides in a single operation, by stitching together 50 fragments of ~1000 nucleotides each. This required crazy tweaks to the assembly protocol, but also the selection of 50 fully inter-compatible overhangs located ~1000 nucleotides apart in the phage’s genome. Such a great assembly design!\nExtra rule #3\nTake into account the imperfections of the ligase (the enzyme that fuses part ends together). For instance the ligase is very bad at fusing sticky ends AAAA and TTTT together, even though they are perfectly complementary, so these sequences should be avoided in your overhang sets. As another example, the ligase can mistakenly fuse together parts with overhangs GGCG and GGCC because, while different, they are not different enough in the eyes of the enzyme.\nIn the first years at the Edinburgh Genome Foundry we used simple rules of thumb to avoid mis-fusions:\n Only use overhang sequences with at least one “A/T” and one “G/C”. All pair of overhangs (and their reverse complements) should differ by at least two nucleotides if possible.  These rules worked pretty well. They were first used in the design of the EMMA standard (25-part assemblies of mammalian genetic constructs, Martella et al. 2017) and at some point we even managed a 35-part assembly, which was very painful but may have been a Golden Gate world record at the time.\nMore recently Potapov et al (2018) mapped exactly which overhangs could be mistakenly fused together and with which frequency (in the figure below, anything outside of the main diagonals is an unwanted fusion between different overhang sequences), providing incredibly useful data that they later used to assemble up to 40 DNA parts together!\nIt’s a computer game after all When things get that complicated, a computer script can go a long way.\nThe most intuitive algorithm to generate a set of valid overhangs is constructive (branch and bound): you start with a single overhang, add another one compatible with the first, then a third one compatible with the first two, and so on. When you cannot add any new overhang, you can try to backtrack (remove one overhang here, add another one there…) in the hope of finding an even better overhang set.\nThis seems to be the approach taken in NEB’s GetSet app (Pryor et al 2020). It works well for reasonably sized assemblies, but if you need to find 20+ compatible overhangs the method may rtake some time, and is not guaranteed to produce a large enough overhang set.\nSince DNA overhang design was an important part of my job at the Edinburgh Genome Foundry and customers kept coming up with difficult problems, I implemented in a Python library (GoldenHinges) with different approaches which I’ll describe below.\nA slick clique trick In this approach, you first list all the overhangs that you’ll allow yourself to use. For instance, all overhangs with at least one G/C and one A/T, which are compatible with ACTC,AGGC, and GATG. You generally end up with a restricted set of possible overhangs:\nNext, you draw an edge between each pair of overhangs that are compatible according to your criteria, which can be for instance “the two overhangs and their reverse-complements must have at least 2 different nucleotides” :\nNow any valid set of overhangs (where all overhangs are inter-compatible) corresponds to a subset of the graph where every pair of nodes is connected by an edge, also known as a graph clique (like your clique of friends in the Facebook friendship graph):\nThe good news is that clique finding has been the bread and butter of graph theorists for a long time, and they have come up with sophisticated algorithms to quickly spot the best and largest cliques of a graph (see Bron-Kerbosch, Tarjan-Trojanowski, to cite only the ones with the most impressive names).\nIt can be daunting to go through all the literature and understand the subtleties of each approach, but I have a PhD in Applied Mathematics, so I googled “python clique finding” and used whichever library the first link told me to. Turns out the excellent Networkx library has all the methods we need! For instance this ~10-line snippet generates a collection of 32 compatible overhangs with 75% G/C:\nimport networkx, itertools, easy_dna overhangs = [ overhang for overhang in easy_dna.all_iupac_variants(\"NNNN\") if len([c for c in overhang if c in \"GC\"]) == 3 # 75% GC ] compatible_overhang_pairs = [ (o1, o2) for (o1, o2) in itertools.combinations(overhangs, 2) if o1 != o2 and (o1 != easy_dna.reverse_complement(o2)) ] graph = networkx.Graph(compatible_overhang_pairs) max_clique, clique_size = networkx.max_weight_clique(graph, None) print (max_clique) #  ['TCCC', 'ACGC', 'CGTC', ... 'GACC'] Have a constraints problem? Try a constraints solver! The clique trick is great for finding new sets of compatible overhangs, but it cannot be applied to sequence decomposition problems where each overhang must be drawn from a different set:\nThe only solutions I’ve seen in the literature were written for the J5 framework (Hillson et al 2011) and the 50,000-nucleotide phage assembly mentioned above (Tsuge et al. 2015), and both use custom-written branch-and-bound algorithms. A low-effort way to leverage sophisticated branch-and-bound algorithms is to use a constraint programming framework, by translating the problem into rules that the framework understands:\n “I have 5 variables V1, V2, V3, V4, V5 representing the overhang sequences.\" “V2 can only take the values GCAC, CACG, and ACGT” “Here is the list of the only compatible sequences for the (V2, V3) overhangs pair”.  Which for the Google OR tools framework translates to:\nfrom ortools.sat.python.cp_model import CpModel, CpSolver, Domain # Problem definition model = CpModel() choices = dict( V1=[\"ATGC\"], V2=[\"GCAC\", \"CACG\", \"ACGT\"], V3=[\"CACG\", \"ACGT\", \"CGTG\"], V4=[\"CATT\", \"ATTG\", \"TTGC\"], V5=[\"AGCA\"] ) variables = [ model.NewIntVarFromDomain(Domain.FromValues(choice_list), name) for name, choice_list in choices.items() ] for v1, v2 in itertools.combinations(variables, 2): model.AddAllowedAssignments((v1, v2), compatible_overhangs_pairs) # Problem resolution solver = CpSolver() solver.Solve(model) print ([solver.Value(var) for var in variables]) # ['ATGC', 'ACGT', 'CGTG', 'ATTG', 'AGCA'] For the code above to fully work, you would need to convert each overhang sequence to a number, e.g. (AAAA→0, AAAC→1, …) so ORTools can handle them – this made the code harder to read so I left it as an exercise. You can also check out the GoldenHinges library, which implements the same rules using the Numberjack framework.\nConclusion I like overhang design problems because they are in many ways characteristic of the field: simple at first glance, but with many gotchas that will ruin your project if you don’t pay attention. They can be a thorn in the foot of whoever wants to extend an existing parts collection or assemble a scarless sequence, and they regularly get in the way of bioengineers' ambitions. But at the end of the day they can be resolved with simple scripts and well-established computational methods, which is a great win for applied maths.\nIf you were rooting against the biologist, don’t worry: once past overhang design, there are many other ways an assembly project can tear someone’s carreer and self-esteem to pieces. Some of these can still be prevented using yet other computational tools, which will be the subject of future posts.\n","wordCount":"2283","inLanguage":"en","datePublished":"2021-04-08T08:47:11+01:00","dateModified":"2021-04-08T08:47:11+01:00","author":{"@type":"Person","name":"Zulko"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://example.org/posts/overhangs/"},"publisher":{"@type":"Organization","name":"Bricks and Scissors","logo":{"@type":"ImageObject","url":"http://example.org/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=http://example.org/ accesskey=h title="Bricks and Scissors (Alt + H)">Bricks and Scissors</a>
<span class=logo-switches></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Strange dominos: the fun and perils of DNA overhang design</h1><div class=post-meta>April 8, 2021&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Zulko</div></header><div class=post-content><blockquote><p><em><strong>Note:</strong> I simplified technical terms and details whenever possible to keep this post focused on the design problems and accessible to a larger audience.</em></p></blockquote><p>If you want to stitch more than 2 bits of DNA together, the most popular method these days is probably Golden Gate Assembly. In a nutshell, you mix DNA fragments in a tube where enzymes will cut their flanks to create <em>overhangs</em> (also called <em>sticky ends</em>), then fuse the overhangs together to form the desired DNA construct:</p><p><img src=/post_assets/overhang_design/simple_dna_assembly.png style="display:block;margin:0 auto" width=550></p><p>How do we know that the DNA parts will assemble in the expected order A-B-C-D, and not C-A-B-D or D-A-C-B ? This is because their DNA sequences are designed so that the 4 nucleotides at the end of each part match the 4 nucleotides at start of the next part, like in a game of dominos:</p><p><img src=/post_assets/overhang_design/successive_overhangs.png style="display:block;margin:0 auto" width=500></p><p>Let&rsquo;s have a closer look at Parts A and B. Each has two strands, with the lower strand being the <em>complementary</em> of the upper one (&ldquo;T&rdquo; complements &ldquo;A&rdquo;, and &ldquo;G&rdquo; complements &ldquo;C&rdquo;):</p><p><img src=/post_assets/overhang_design/parts_closer_look.png style="display:block;margin:0 auto" width=500></p><p>When the flank-cutting enzyme cuts the right flank of Part A, it leaves an overhang of four &ldquo;bare&rdquo; nucleotides on the lower strand. When it cuts the left flank of Part B, it leaves another overhang, this time on the upper strand:</p><p><img src=/post_assets/overhang_design/digestion_detail.png style="display:block;margin:0 auto" width=450></p><p>The two ends are perfectly complementary and will be fused to form a single DNA molecule:</p><p><img src=/post_assets/overhang_design/ligation_detail.png style="display:block;margin:0 auto" width=350></p><p>Bioengineers can assemble many parts at once using this method &ndash; typically 10, 20, or even 30+ parts for the most ambitious projects. But as the number of parts increases, so does the difficulty of finding overhang sequences that play well together.</p><h2 id=rules-of-the-game>Rules of the game<a hidden class=anchor aria-hidden=true href=#rules-of-the-game>#</a></h2><p>Throughout the DNA assembly protocol, several copies of each part are freely floating around in the assembly mix:</p><p><img src=/post_assets/overhang_design/parts_in_water.png style="display:block;margin:0 auto" width=450></p><p>One thing we really want to avoid here is the accidental fusion of parts that were not meant to fuse together, which would create &ldquo;monster&rdquo; DNA molecules and prevent the formation of the desired construct. To this end, a few logical rules must be observed.</p><p><strong>Design rule #1</strong></p><p>Don&rsquo;t use the same overhang sequence for different part fusions. If the overhang that fuses Part A to B is the same that fuses Part C to D, then two varieties of constructs will be formed, one of which is missing parts B and C. Yikes!</p><p><img src=/post_assets/overhang_design/skipped_overhang.png style="display:block;margin:0 auto" width=450></p><p><strong>Design rule #2</strong></p><p>Beware of reverse-complementary overhangs! In the example below, each fusion is using a different overhang sequence, which looks great. But notice that the right overhang of Part C, once flipped over, is actually complementary to the right overhang of Part A:</p><p><img src=/post_assets/overhang_design/reverse_complements.png style="display:block;margin:0 auto" width=600></p><p>This is bad because many copies of Parts A and C will be lost in this useless fusion. Other copies of the parts may still assemble in the right order to produce the expected construct, but the probability of success will be decreased.</p><p><strong>Design rule #3</strong></p><p>Don&rsquo;t use overhang sequences that are their own reverse-complements. For instance if a part has a CATG overhang then different copies of this part can fuse together, resulting here again in a waste of fragments and lower assembly success rates.</p><p><img src=/post_assets/overhang_design/palyndromic_overhang.png style="display:block;margin:0 auto" width=500></p><h3 id=pop-quiz>Pop quiz!<a hidden class=anchor aria-hidden=true href=#pop-quiz>#</a></h3><p><strong>Problem 1</strong></p><p>According to the rules above, which letter should replace the X?</p><p><img src=/post_assets/overhang_design/problem_1.png style="display:block;margin:0 auto" width=550></p><p><strong>Problem 2</strong></p><p>Is this overhang set valid? List the reasons why not.</p><p><img src=/post_assets/overhang_design/problem_2.png style="display:block;margin:0 auto" width=600></p><p><strong>Problem 3</strong></p><p>Let&rsquo;s throw some real-world shade! What would you improve in the overhang design of the <a href=https://pubs.acs.org/doi/10.1021/acssynbio.6b00031>Ecoflex</a> bacterial engineering standard? (you don&rsquo;t need to understand the figures to answer, simply look at the overhang sequences).</p><p><img src=https://media.addgene.org/data/easy-thumbnails/filer_public/cms/filer_public/57/70/577078e5-b78e-4f6f-b380-e9de2eed96f8/ecoflex-figure-1b.png__400x498_q85_subsampling-2_upscale.png style="display:block;margin:0 auto" width=500></p><p><strong>Still too easy?</strong></p><p>If these small examples made you hesitate for a few seconds, imagine how it feels to design a collection of 20+ overhangs from scratch, where checking the compatibility of all overhangs and their reverse-complements takes hundreds of pair-wise comparisons. After hours (if not days) of careful design, you may still make a few mistakes that will end up costing you weeks of work and thousands of dollars down the line! But wait, it gets worse.</p><h2 id=advanced-rules-for-advanced-players>Advanced rules for advanced players<a hidden class=anchor aria-hidden=true href=#advanced-rules-for-advanced-players>#</a></h2><p>Real-life DNA assembly projects generally come with their own extra constraints and cave-ats. This section will be a bit more technical, but you can also just glance over and head to the next section on computational resolution.</p><p><strong>Extra rule #1</strong></p><p>Some overhang sequences can be imposed. This typically happens when you already have genetic parts in the fridge that use overhangs ATGC, AATC and GGCA, and you want the next overhangs you design to be compatible with these, so that old and new parts can be assembled in the same constructs.</p><p>Other constraints arise when designing overhangs that will appear at biologically significant locations of the final construct. For instance, in the Phytobrick standard for plant engineering, the DNA parts represent different functional modules of a same gene, with one part encoding a protein, and other parts encoding flanking &ldquo;tags&rdquo; (which are biological markers that will send a signal to the cell or the biologist):</p><p><img src=/post_assets/overhang_design/phytobrick.png style="display:block;margin:0 auto" width=650></p><p>Notice that the second overhang <code>AATG</code> is at the very beginning of a coding sequence, which is why it contains <code>ATG</code>, the sequence of the Methionine <em>start codon</em>. In the next overhang, <code>AGCC</code>, the <code>GCC</code> codes for Alanine, a very small amino-acid commonly used in &ldquo;chains&rdquo; linking proteins and tags together. Likewise , <code>TCG</code> in the next overhang codes for Serine, another small amino-acid used in chains. All other overhang sequences in the standard (not shown here) have therefore had to be designed to be compatible with these imposed sequences.</p><p><strong>Extra rule #2</strong></p><p>No scars! In the most flexible bioengineering projects, you are allowed to add a few nucleotides here and therein the desired sequences to make them easier to assemble from parts. These added nucleotides with no function other than to enable construction are called &ldquo;assembly scars&rdquo;.</p><p>In more demanding bioengineering projects, the desired sequences are so biologically significant and tightly designed that they absolutely cannot be modified &ndash; they don&rsquo;t allow scars. For your assembly, this means that the overhang sequences <em>must</em> be part of the desired final construct sequence:</p><p><img src=/post_assets/overhang_design/scarless_assembly.png style="display:block;margin:0 auto" width=650></p><p>This constraint still leaves some choice in the overhang sequences. For instance we could decide that the first fragment should fuse with the second fragment <em>somewhere</em> in a certain 6-nucleotide region, which gives us 3 options depending on where exactly the fusion occurs:</p><p><img src=/post_assets/overhang_design/fusion_in_this_zone.png style="display:block;margin:0 auto" width=200></p><p>Each overhang of the assembly will be picked from a different region of the final sequence, and so will have its own set of options, making the design overhang problem look like this:</p><p><img src=/post_assets/overhang_design/cut_around_here_fragments.png style="display:block;margin:0 auto" width=700></p><p>The example above is a bit underwhelming, but biologists have managed some really impressive scarless assemblies: the schema below describes how <a href=https://www.nature.com/articles/srep10655>Tsuge et al., (2015)</a> assembled a whole <em>phage virus</em> genome of ~50,000 nucleotides in a single operation, by stitching together 50 fragments of ~1000 nucleotides each. This required crazy tweaks to the assembly protocol, but also the selection of 50 fully inter-compatible overhangs located ~1000 nucleotides apart in the phage&rsquo;s genome. Such a great assembly design!</p><p><img src=/post_assets/overhang_design/tsuge_et_al.png style="display:block;margin:0 auto" width=650></p><p><strong>Extra rule #3</strong></p><p>Take into account the imperfections of the ligase (the enzyme that fuses part ends together). For instance the ligase is very bad at fusing sticky ends <code>AAAA</code> and <code>TTTT</code> together, even though they are perfectly complementary, so these sequences should be avoided in your overhang sets. As another example, the ligase can mistakenly fuse together parts with overhangs <code>GGCG</code> and <code>GGCC</code> because, while different, they are not <em>different enough</em> in the eyes of the enzyme.</p><p>In the first years at the Edinburgh Genome Foundry we used simple rules of thumb to avoid mis-fusions:</p><ul><li>Only use overhang sequences with at least one &ldquo;A/T&rdquo; and one &ldquo;G/C&rdquo;.</li><li>All pair of overhangs (and their reverse complements) should differ by at least two nucleotides if possible.</li></ul><p>These rules worked pretty well. They were first used in the design of the EMMA standard (25-part assemblies of mammalian genetic constructs, <a href=https://pubs.acs.org/doi/10.1021/acssynbio.7b00016>Martella et al. 2017</a>) and at some point we even managed a 35-part assembly, which was very painful but may have been a Golden Gate world record at the time.</p><p>More recently <a href=https://pubs.acs.org/doi/10.1021/acssynbio.8b00333>Potapov et al (2018)</a> mapped exactly which overhangs could be mistakenly fused together and with which frequency (in the figure below, anything outside of the main diagonals is an unwanted fusion between different overhang sequences), providing incredibly useful data that they later used to assemble up to 40 DNA parts together!</p><p><img src=/post_assets/overhang_design/potapov_et_al.png style="display:block;margin:0 auto" width=450></p><h2 id=its-a-computer-game-after-all>It&rsquo;s a computer game after all<a hidden class=anchor aria-hidden=true href=#its-a-computer-game-after-all>#</a></h2><p>When things get that complicated, a computer script can go a long way.</p><p>The most intuitive algorithm to generate a set of valid overhangs is constructive (<em>branch and bound</em>): you start with a single overhang, add another one compatible with the first, then a third one compatible with the first two, and so on. When you cannot add any new overhang, you can try to <em>backtrack</em> (remove one overhang here, add another one there&mldr;) in the hope of finding an even better overhang set.</p><p>This seems to be the approach taken in NEB&rsquo;s GetSet app (<a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0238592">Pryor et al 2020</a>). It works well for reasonably sized assemblies, but if you need to find 20+ compatible overhangs the method may rtake some time, and is not guaranteed to produce a large enough overhang set.</p><p>Since DNA overhang design was an important part of my job at the Edinburgh Genome Foundry and customers kept coming up with difficult problems, I implemented in a Python library (<a href=https://github.com/Edinburgh-Genome-Foundry/GoldenHinges>GoldenHinges</a>) with different approaches which I&rsquo;ll describe below.</p><h3 id=a-slick-clique-trick>A slick clique trick<a hidden class=anchor aria-hidden=true href=#a-slick-clique-trick>#</a></h3><p>In this approach, you first list all the overhangs that you&rsquo;ll allow yourself to use. For instance, all overhangs with at least one G/C and one A/T, which are compatible with ACTC,AGGC, and GATG. You generally end up with a restricted set of possible overhangs:</p><p><img src=/post_assets/overhang_design/overhangs_no_edges.png style="display:block;margin:0 auto" width=400></p><p>Next, you draw an edge between each pair of overhangs that are compatible according to your criteria, which can be for instance <em>&ldquo;the two overhangs and their reverse-complements must have at least 2 different nucleotides&rdquo;</em> :</p><p><img src=/post_assets/overhang_design/compatibility_graph.png style="display:block;margin:0 auto" width=400></p><p>Now any valid set of overhangs (where all overhangs are inter-compatible) corresponds to a subset of the graph where every pair of nodes is connected by an edge, also known as a graph <em>clique</em> (like your <em>clique</em> of friends in the Facebook friendship graph):</p><p><img src=/post_assets/overhang_design/clique.png style="display:block;margin:0 auto" width=400></p><p>The good news is that clique finding has been the bread and butter of graph theorists for a long time, and they have come up with sophisticated algorithms to quickly spot the best and largest cliques of a graph (see Bron-Kerbosch, Tarjan-Trojanowski, to cite only the ones with the most impressive names).</p><p>It can be daunting to go through all the literature and understand the subtleties of each approach, but I have a PhD in Applied Mathematics, so I googled <em>&ldquo;python clique finding&rdquo;</em> and used whichever library the first link told me to. Turns out the excellent Networkx library has all the methods we need! For instance this ~10-line snippet generates a collection of 32 compatible overhangs with 75% G/C:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> networkx<span style=color:#f92672>,</span> itertools<span style=color:#f92672>,</span> easy_dna

overhangs <span style=color:#f92672>=</span> [
    overhang
    <span style=color:#66d9ef>for</span> overhang <span style=color:#f92672>in</span> easy_dna<span style=color:#f92672>.</span>all_iupac_variants(<span style=color:#e6db74>&#34;NNNN&#34;</span>)
    <span style=color:#66d9ef>if</span> len([c <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> overhang <span style=color:#66d9ef>if</span> c <span style=color:#f92672>in</span> <span style=color:#e6db74>&#34;GC&#34;</span>]) <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>  <span style=color:#75715e># 75% GC</span>
]
compatible_overhang_pairs <span style=color:#f92672>=</span> [
    (o1, o2)
    <span style=color:#66d9ef>for</span> (o1, o2) <span style=color:#f92672>in</span> itertools<span style=color:#f92672>.</span>combinations(overhangs, <span style=color:#ae81ff>2</span>)
    <span style=color:#66d9ef>if</span> o1 <span style=color:#f92672>!=</span> o2 <span style=color:#f92672>and</span> (o1 <span style=color:#f92672>!=</span> easy_dna<span style=color:#f92672>.</span>reverse_complement(o2))
]
graph <span style=color:#f92672>=</span> networkx<span style=color:#f92672>.</span>Graph(compatible_overhang_pairs)
max_clique, clique_size <span style=color:#f92672>=</span> networkx<span style=color:#f92672>.</span>max_weight_clique(graph, None)
<span style=color:#66d9ef>print</span> (max_clique)
<span style=color:#75715e># &gt; [&#39;TCCC&#39;, &#39;ACGC&#39;, &#39;CGTC&#39;, ... &#39;GACC&#39;]</span>
</code></pre></div><h3 id=have-a-constraints-problem-try-a-constraints-solver>Have a constraints problem? Try a constraints solver!<a hidden class=anchor aria-hidden=true href=#have-a-constraints-problem-try-a-constraints-solver>#</a></h3><p>The clique trick is great for finding new sets of compatible overhangs, but it cannot be applied to sequence decomposition problems where each overhang must be drawn from a different set:</p><p><img src=/post_assets/overhang_design/cut_around_here_fragments.png style="display:block;margin:0 auto" width=650></p><p>The only solutions I&rsquo;ve seen in the literature were written for the J5 framework (<a href=https://pubs.acs.org/doi/pdf/10.1021/sb2000116>Hillson et al 2011</a>) and the 50,000-nucleotide phage assembly mentioned above (<a href=https://www.nature.com/articles/srep10655>Tsuge et al. 2015</a>), and both use custom-written <em>branch-and-bound</em> algorithms. A low-effort way to leverage sophisticated branch-and-bound algorithms is to use a constraint programming framework, by translating the problem into rules that the framework understands:</p><ul><li><em>&ldquo;I have 5 variables V1, V2, V3, V4, V5 representing the overhang sequences."</em></li><li><em>&ldquo;V2 can only take the values GCAC, CACG, and ACGT&rdquo;</em></li><li><em>&ldquo;Here is the list of the only compatible sequences for the (V2, V3) overhangs pair&rdquo;</em>.</li></ul><p>Which for the <a href=https://developers.google.com/optimization/cp>Google OR tools</a> framework translates to:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> ortools.sat.python.cp_model <span style=color:#f92672>import</span>  CpModel, CpSolver, Domain

<span style=color:#75715e># Problem definition</span>
model <span style=color:#f92672>=</span> CpModel()
choices <span style=color:#f92672>=</span> dict(
    V1<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;ATGC&#34;</span>],
    V2<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;GCAC&#34;</span>, <span style=color:#e6db74>&#34;CACG&#34;</span>, <span style=color:#e6db74>&#34;ACGT&#34;</span>],
    V3<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;CACG&#34;</span>, <span style=color:#e6db74>&#34;ACGT&#34;</span>, <span style=color:#e6db74>&#34;CGTG&#34;</span>],
    V4<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;CATT&#34;</span>, <span style=color:#e6db74>&#34;ATTG&#34;</span>, <span style=color:#e6db74>&#34;TTGC&#34;</span>],
    V5<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;AGCA&#34;</span>]
)
variables <span style=color:#f92672>=</span> [
    model<span style=color:#f92672>.</span>NewIntVarFromDomain(Domain<span style=color:#f92672>.</span>FromValues(choice_list), name)
    <span style=color:#66d9ef>for</span> name, choice_list <span style=color:#f92672>in</span> choices<span style=color:#f92672>.</span>items()
]
<span style=color:#66d9ef>for</span> v1, v2 <span style=color:#f92672>in</span> itertools<span style=color:#f92672>.</span>combinations(variables, <span style=color:#ae81ff>2</span>):
    model<span style=color:#f92672>.</span>AddAllowedAssignments((v1, v2), compatible_overhangs_pairs)

<span style=color:#75715e># Problem resolution</span>
solver <span style=color:#f92672>=</span> CpSolver()
solver<span style=color:#f92672>.</span>Solve(model)
<span style=color:#66d9ef>print</span> ([solver<span style=color:#f92672>.</span>Value(var) <span style=color:#66d9ef>for</span> var <span style=color:#f92672>in</span> variables])
<span style=color:#75715e>#&gt; [&#39;ATGC&#39;, &#39;ACGT&#39;, &#39;CGTG&#39;, &#39;ATTG&#39;, &#39;AGCA&#39;]</span>
</code></pre></div><p>For the code above to fully work, you would need to convert each overhang sequence to a number, e.g. (AAAA→0, AAAC→1, &mldr;) so ORTools can handle them &ndash; this made the code harder to read so I left it as an exercise. You can also check out the <a href=https://github.com/Edinburgh-Genome-Foundry/GoldenHinges/blob/b4af31d671189956c55a3339a2946861a64e5f02/goldenhinges/OverhangsSelector.py#L154>GoldenHinges library</a>, which implements the same rules using the <a href=https://github.com/eomahony/Numberjack>Numberjack</a> framework.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I like overhang design problems because they are in many ways characteristic of the field: simple at first glance, but with many gotchas that will ruin your project if you don&rsquo;t pay attention. They can be a thorn in the foot of whoever wants to extend an existing parts collection or assemble a scarless sequence, and they regularly get in the way of bioengineers' ambitions. But at the end of the day they can be resolved with simple scripts and well-established computational methods, which is a great win for applied maths.</p><p>If you were rooting against the biologist, don&rsquo;t worry: once past overhang design, there are many other ways an assembly project can tear someone&rsquo;s carreer and self-esteem to pieces. Some of these can still be prevented using yet other computational tools, which will be the subject of future posts.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=http://example.org/>Bricks and Scissors</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>